<!DOCTYPE html>
<html lang="en">

<head>
    <title>How to use Room database and migration for version upgrade</title>
    <!-- Meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="favicon.ico">
    <link href='http://fonts.googleapis.com/css?family=Lato:300,400,300italic,400italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Montserrat:400,700' rel='stylesheet' type='text/css'>
    <!-- Global CSS -->
    <link rel="stylesheet" href="assets/plugins/bootstrap/css/bootstrap.min.css">
    <!-- Plugins CSS -->
    <link rel="stylesheet" href="assets/plugins/font-awesome/css/font-awesome.css">

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/octicons/2.0.2/octicons.min.css">

    <!-- Theme CSS -->
    <link id="theme-style" rel="stylesheet" href="assets/css/styles.css">
</head>

<body>
    <header class="header">
        <div class="container">
            <div class="blog-content pull-left">
                <h1 class="title">How to use Room database and migration for version upgrade</h1>
            </div>
        </div>
    </header>

    <div class="container sections-wrapper">
        <div class="content">
            <p>
                Google introduced room persistence library in google io 2017. Room library is very helpful for developer who use sqlite for local database in android. It is layer over sqlite which makes writing databse code easy and simple. This blog post is about how
                to use room and what to do in case of complex situation. Let's start with how to use room.
            </p>
            <p>
                We write every table as entity, so if you want to create a student record table then you can create it as
            </p>
            <pre><code class="blog-code">
            @Entity(primaryKeys = "id") //if you want to use multiple primary keys then you have to define it here. like primaryKeys = ["id","secondId"]
            //By default class name is use as table name but if you want to give nay particular name to table you can use tableName = "name_you_want" like @Entity(primaryKeys = "id", tableName = "name_you_want")
            data class Student{
                //if there is single primary key you can define it with column name like @PrimaryKey val id: String then there is no need to define primary 
                //on top of class name i.e with entity
                val id: String,
                val name: String,
                val roll: String,
                val class: String,
                val section: String
            }
            </code></pre>
            <p>
                If you want to use any custom class like ArrayList in your entity then use TypConverter to save it in room. Using TypConverter room convert custom class in json string and save it in databse and when we query then it convert this json string into custom
                class. We use Gson for that.
            </p>
            <p>
                <pre>
                    <code>
                        class ListConverter{
                        @TypeConverter
                        fun toArrayList(listString: String): ArrayList<String> {
                            val listStringType = object : TypeToken<ArrayList<String>>() {}.type
                                return Gson().fromJson(listString, listStringType)
                            }
                                                        
                        @TypeConverter
                        fun fromMapGroupInfo(list: ArrayList<String>): String {
                            val gson = Gson()
                                return gson.toJson(list)
                        }
                    }
                    </code>
                </pre>
                <br>and use this type converter in entity
                <pre><code>@TypeConverters(ListConverter::class) val idList: List<String></String></code></pre>
            </p>
            <P>
                Then we need to create a dao class to do operation on this table. We write all the queries in this class. for example
                <pre>
                    <code>
                        @Dao
                        interface StudentDao{
                           //if you want to handle conflict like if you insert the row with primary key already present in app then you can use
                           //  conflict strategy like @Insert(onConflict = OnConflictStrategy.IGNORE) IGNORE mean row will not be inserted and REPLACE 
                           //  means row will replace by this new row.
                           @Insert
                           fun insertStudents(student: Student)
                        
                           @Query("SELECT * FROM Student") //Student is table name so if you have defined your table name explicitly in entity using tableName 
                           //then you have to use that name.
                            fun selectAllStudents(): List<Student>
                        }
                    </code>
                </pre>
            </P>
            <p>
                The class, where we initialize room with all information like database name and which contain information like all the tables present in app and abstract method to access the dao class so that we can use query written in that dao, extends RoomDatabse
                class. We are using single instance of room(singleton). There is no use of initializing room every time.
                <pre>
                    <code>
                        @Database(entities = {Student::class.java,...}, version = version_of_database(int value), exportSchema = false) 
                        //exportSchema means you want to keep track version history of our tables or not.
                        //if any type converter present then have to mention that
                        @TypeConverters({ListConverter::class.java})
                        public abstract class AppDatabse: RoomDatabase{
                           public abstract StudentDao studentDao();
                           companion object {
                              @JvmStatic
                              var instance: AppDatabase? = null
                              private set
                        
                              //call it from application to save memory leak problem.
                              fun initInstance(application: Application) {
                                 if (instance == null) {
                                   instance = Room.databaseBuilder(application.applicationContext, AppDatabase::class.java, //your database name).build()
                                 }
                              }
                           }
                        }
                    </code>
                </pre>
            </p>
            <p>
                Since we are using a single instance of room, so initialize room in onCreate in application class in android.
                <pre>
                    <code>
                        AppDatabase.initInstance(this)
                    </code>
                </pre>
            </p>
            <p>
                If you want to make change in database which is already present in users android phone memory then you have to write migration so that it does not affect old tables. It's better to keep all the migration code in one class so that you can manage it easily.
            </p>
            <p>
                Let's we want to add table student in out database with column id(String type, Priamry key), class(int, non null), section(String, non null), point(float, non null)
                <pre>
                    <code>
                        public class DatabaseMigration{
                           companion object{
                             //use variable name such that it give information about migration version change from and to
                             val migration_1_2 = object : Migration(1,2){
                               override fun migrate(database: SupportSQLiteDatabase){
                                  database.execSQL("CREATE TABLE Student (id TEXT NOT NULL, class INTEGER NOT NULL, section TEXT NOT NULL, point REAL NOT NULL, 
                                  PRIMARY KEY(id))")
                                }
                            }
                          }
                        }
                        Note: Since Custom class is saved using TypeConverter and room database save it after converting it to json string so it is TEXT data type.
                    </code>
                </pre>
            </p>
            <p>
                and then add migration when you initialize room
                <pre>
                    <code>
                        instance = Room.databaseBuilder(application.applicationContext, AppDatabase::class.java, Strings.DATABASE_NAME //your database name)
                        .addMigration(DatabaseMigration.migration_1_2).build()
                    </code>
                </pre>
            </p>
            <p>
                If you want to update table like add column or drop column then alter table like
                <pre>
                    <code>
                        database.execSQL("ALTER TABLE table_name ADD COLUMN column_name") OR database.execSQL("ALTER TABLE table_name DROP COLUMN column_name")
                    </code>
                </pre>
            </p>
        </div>
    </div>
</body>